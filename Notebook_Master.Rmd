---
title: "NFL Big Data Bowl 2024 - Probabilistic Tackling"
output: html_notebook
---

# Scope and Research Plan

How can one rank defensive players in terms of their tackling ability based on empirical data? One could simply add up how many tackles each player has achieved and assign the players with the most tackles as the best tacklers. This approach would be too simplistic. It doesn't consider how many defensive plays in which the player was involved. A player with 5 tackles across 10 plays is a better tackler than a player with 5 tackles across 200 plays, all else equal. However, this still doesn't consider situational context. Despite being involved in most plays, a defensive lineman may rarely have a tackling opportunity on passing plays because they are pursuing the quarterback as opposed to wide receivers or tight ends - the usual targets for passing plays. Said defensive lineman is going to have a relatively low tackles-to-number of plays ratio. One needs to account for situational context.

My strategy for the Big Data Bowl of 2024 is to follow the Metric Track and utilize the next gen stats tracking data to try to account for this situational variable. For every tackle play, my goal is to assign a tackling probability to each defensive player on the field. The probability assigned to each player will be predicted from a predictive model that uses variables such as distance from the receiver at the time of pass release, direction defensive player is facing at time of pass release, speed at which the defensive player is traveling, speed of ball carrier, etc.

We will then have an assigned tackling probability (0-100%) for every defensive player for every play in which they were involved. We can then sum up these probabilities for each player to arrive at an expected number of tackles for each player. We can then compare how many tackles each player actually achieved to their expected number of tackles and see who has the best (and worst) actual-to-expected ratio.

Example: Jalen Ramsey is right next to the wide receiver who catches the ball, and the receiver has no acceleration when the catch is made. Jalen's predicted probability of tackling the player will be relatively high compared to Raekwon Davis who is near the QB attempting a sack. Jalen may get a 90% tackling probability assigned to him, while Raekwon may get a 0.5% tackling probability assigned. If Jalen doesn't get the tackle, it will certainly hurt his actual-to-expected ratio, whereas Raekwon's actual-to-expected ratio will barely be impacted if he doesn't get the tackle.

Given the vastly different factors that affect passing versus running plays, I am choosing to focus my predictive model on passing plays for this project. Although, the approach and concepts could certainly be applied to running plays; the predictive variables that go into the model would significantly different.

## Definitions

A few important definitions:

-   For purposes of this project, I am defining a "tackle" as a tackle, assisted tackle, or a forced fumble. All 3 scenarios are being treated as equal in value.

# Data Cleansing and Structuring

```{r Setup, include=FALSE}

# load libraries
library(dplyr, quietly = TRUE)
library(data.table, quietly = TRUE)
library(RSQLite, quietly = TRUE)
library(ggplot2, quietly = TRUE)

# connect to SQLite DB
sqlite_con <- dbConnect(RSQLite::SQLite(), dbname = "sqlite_data/nfl.db")

# load key data tables. tracking is NOT loaded here, as it's huge. we'll load a subset of that later
tackles.DT <- as.data.table(readRDS("rds_data/tackles.rds"))
plays.DT <- as.data.table(readRDS("rds_data/plays.rds"))
games.DT <- as.data.table(readRDS("rds_data/games.rds"))
players.DT <- as.data.table(readRDS("rds_data/players.rds"))
```

```{r Plays_of_Interest, include=FALSE}

# assign should_be_tackle
# equals 1 for any tackle, assist, or forced fumble
tackles.DT[, should_be_tackle := ifelse(1*tackle + 1*assist + 1*forcedFumble + 0*pff_missedTackle > 0, 1, 0)]

# determine plays that have a should_be_tackle event
should.be.tackle.plays <- unique(tackles.DT[should_be_tackle == 1, .(gameId, playId)])

# load plays data
plays.DT <- as.data.table(readRDS("rds_data/plays.rds"))

# determine passing plays using the completed pass indicator from the plays data
# incomplete pass obviously won't result in a should-be-tackle event
# scrambles are considered run plays in this context
# and blanks are either running plays or non-interests
passing.plays <- unique(plays.DT[passResult == "C", .(gameId, playId)])

# we can now inner join our passing plays and should-be-tackle plays to get our list of passing plays that resulted in a should-be-tackle event
plays.of.interest <- merge(should.be.tackle.plays,
                           passing.plays,
                           by = c("gameId", "playId"))
# remove uneeded data
rm(should.be.tackle.plays)
rm(passing.plays)

# write to our SQLite database
dbWriteTable(sqlite_con, name = "plays_of_interest", value = plays.of.interest, overwrite = TRUE)
```

```{sql Grab_Tracking_Data, connection=sqlite_con, output.variable = "tracking.DT"}

-- grab the tracking data only for the plays of interest

SELECT
  tracking_all.*

FROM tracking_all -- all tracking data INNER JOINed with our subset of plays
  INNER JOIN plays_of_interest ON (tracking_all.gameId = plays_of_interest.gameId AND 
                                    tracking_all.playId = plays_of_interest.playId)
                                    
--WHERE
  -- stick to one game and play for now for testing purposes; expand later
  --tracking_all.gameId = 2022090800
  --AND tracking_all.playId = 122
  
ORDER BY
  tracking_all.gameId,
  tracking_all.playId,
  tracking_all.frameId

```

```{r Manipulate_Tracking_Data, include=FALSE}

# We need to make a few additions and manipulations to the tracking data.

tracking.DT <- as.data.table(tracking.DT)

# We need to add a simple field to the tracking data to indicate which team is on offense or defense
# re-structure the plays data to flag offsensive vs defensive team
off.def.teams.by.play <- melt(plays.DT, measure.vars = c("possessionTeam", "defensiveTeam"))
setnames(off.def.teams.by.play, "value", "Team")
off.def.teams.by.play[, Off_or_Def := ifelse(variable == "possessionTeam", "Offense", "Defense")]
off.def.teams.by.play <- off.def.teams.by.play[, .(gameId, playId, Team, Off_or_Def)]

# join the Off_or_Def indicator to our tracking data
tracking.DT <- merge(tracking.DT,
                     off.def.teams.by.play,
                     by.x = c("gameId", "playId", "club"),
                     by.y = c("gameId", "playId", "Team"),
                     all.x = TRUE)

# remove off.vs.def data
rm(off.def.teams.by.play)
```

```{r include=FALSE}

# want to add a field to the tracking data that shows if the player was the player (or one of the players) that got the tackle. this will be useful for our animation

tracking.DT <- merge(tracking.DT,
                     tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                     by = c("gameId", "playId", "nflId"),
                     all.x = TRUE)

tracking.DT[is.na(should_be_tackle), should_be_tackle := 0]
```

```{r Start_Building_Model_Data, include=FALSE}

# Start building the model database of predictive variables and the target variable.

model.DT <- unique(tracking.DT[Off_or_Def == "Defense", # only want defensive players in the model
                        .(gameId,
                          playId,
                          nflId,
                          displayName)])
```

```{r Add_Should_be_Tackles, include=FALSE}

# Start adding key stats to the model data.

# Add indicator if player had a should-be-tackle.

model.DT <- merge(model.DT,
                  tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE)

# change NAs to 0
model.DT[is.na(should_be_tackle), should_be_tackle := 0]

```

It's worth pausing here, as we now have a database of each player and how many tackles (remember, tackle here means a tackle, assist, or a forced fumble) they made across the 9 weeks of data. We'll see how these raw tackle counts - unadjusted for situational context - stack up against our final model.

```{r echo=FALSE}
simple.tackles.by.player <- model.DT[, .(Tackles = sum(should_be_tackle)), by = .(nflId, displayName)]
simple.tackles.by.player[, name_plus_id := paste(displayName, " (nflId ", nflId, ")", sep="")]

simple.tackles.by.player <- simple.tackles.by.player[order(-Tackles)]
top_25_players <- simple.tackles.by.player[1:20]

ggplot(top_25_players, aes(x = Tackles, y = reorder(displayName, Tackles))) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_text(aes(label = Tackles), hjust = -0.1, size = 3) +
  labs(title = 'Passing Tackles by Player (Top 20)',
       x = '') +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank())
```

```{r Ball_Carrier_Data, include=FALSE}

# start adding variables to the model

# add ball Carrier to tracking data
tracking.DT <- merge(tracking.DT,
                     plays.DT[, .(gameId, playId, ballCarrierId)],
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# calculate receiver coordinates and play direction at time of pass catch
receiver.coordinates.at.catch <- tracking.DT[nflId == ballCarrierId & event == "pass_outcome_caught",
                                                     .(gameId,
                                                       playId,
                                                       # rename column for easier joining later
                                                       receiver_at_pass_catch_x = x,
                                                       # rename column for easier joining later
                                                       receiver_at_pass_catch_y = y)
                                                   ]

# join receiver coordinates to tracking data
tracking.DT <- merge(tracking.DT,
                     receiver.coordinates.at.catch,
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# can remove receiver coordinates at time of pass catch temporary data table
rm(receiver.coordinates.at.catch)

# calculate if player is between receiver and endzone at time of catch
tracking.DT[, front_or_behind_receiver := ifelse(playDirection == "left", 
        ifelse(x <= receiver_at_pass_catch_x, "front", "behind"),
        ifelse(x > receiver_at_pass_catch_x, "front", "behind"))]

# calculate distance from receiver
tracking.DT[, dist_from_receiver_at_pass_catch := sqrt((x - receiver_at_pass_catch_x)^2 + 
                                                           (y - receiver_at_pass_catch_y)^2)]

# load our geometry functions defined in a separate script
source("geometry_functions.R")

# calculate orientation angle relative to position of receiver
tracking.DT[, o_relative_to_receiver := angle_relative_to_point(x,
                                                                y,
                                                                o,
                                                                receiver_at_pass_catch_x,
                                                                receiver_at_pass_catch_y)]

# calculate direction angle relative to position of receiver
tracking.DT[, dir_relative_to_receiver := angle_relative_to_point(x,
                                                                y,
                                                                dir,
                                                                receiver_at_pass_catch_x,
                                                                receiver_at_pass_catch_y)]



# remove no longer needed stats to save space
#tracking.DT[, receiver_at_pass_catch_x := NULL]
#tracking.DT[, receiver_at_pass_catch_y := NULL]

# add calculated stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId, playId, nflId,
                                front_or_behind_receiver,
                                dist_from_receiver_at_pass_catch,
                                o_relative_to_receiver,
                                dir_relative_to_receiver
                                )],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )

 

# remove distance from receiver from tracking data (save space)
#tracking.DT[, dist_from_receiver_at_pass_catch := NULL]
```

```{r Add_Angle_Direction_Data, include=FALSE}

# Add difference in angle of direction and angle of orientation from receiver at time of catch.

# calculate receiver direction angle and at time of pass catch
receiver.angles.at.catch <- tracking.DT[nflId == ballCarrierId &
                                        event == "pass_outcome_caught",
                                         .(gameId,
                                           playId,
                                           # rename columns for easier joining later
                                           receiver_at_pass_catch_o = o,
                                           receiver_at_pass_catch_dir = dir,
                                           receiver_at_pass_catch_s = s,
                                           receiver_at_pass_catch_a = a)
                                       ]

# join receiver angles data to tracking data
tracking.DT <- merge(tracking.DT,
                     receiver.angles.at.catch,
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# can remove receiver coordinates at time of pass catch
rm(receiver.angles.at.catch)

# calculate angle and speed differences from receiver
# orientation angle (take absolute degree difference)
tracking.DT[, diff_in_o_from_receiver_at_pass_catch := abs(o - receiver_at_pass_catch_o)]
tracking.DT[, diff_in_o_from_receiver_at_pass_catch := ifelse(diff_in_o_from_receiver_at_pass_catch > 180, 360 - diff_in_o_from_receiver_at_pass_catch, diff_in_o_from_receiver_at_pass_catch)]

# direction angle (take absolute degree difference)
tracking.DT[, diff_in_dir_from_receiver_at_pass_catch := abs(dir - receiver_at_pass_catch_dir)]
tracking.DT[, diff_in_dir_from_receiver_at_pass_catch := ifelse(diff_in_dir_from_receiver_at_pass_catch > 180, 360 - diff_in_dir_from_receiver_at_pass_catch, diff_in_dir_from_receiver_at_pass_catch)]

# speed and acceleration (don't take absolute difference)
tracking.DT[, diff_in_s_from_receiver_at_pass_catch := s - receiver_at_pass_catch_s]
tracking.DT[, diff_in_a_from_receiver_at_pass_catch := a - receiver_at_pass_catch_a]

# remove no longer needed stats to save space
#tracking.DT[, receiver_at_pass_catch_o := NULL]
#tracking.DT[, receiver_at_pass_catch_dir := NULL]
#tracking.DT[, receiver_at_pass_catch_s := NULL]
#tracking.DT[, receiver_at_pass_catch_a := NULL]

# add stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId,
                                playId,
                                nflId,
                                diff_in_o_from_receiver_at_pass_catch,
                                diff_in_dir_from_receiver_at_pass_catch,
                                diff_in_s_from_receiver_at_pass_catch,
                                diff_in_a_from_receiver_at_pass_catch)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )

# remove stats from tracking data (save space)
#tracking.DT[, diff_in_o_from_receiver_at_pass_catch := NULL]
#tracking.DT[, diff_in_dir_from_receiver_at_pass_catch := NULL]
#tracking.DT[, diff_in_s_from_receiver_at_pass_catch := NULL]
#tracking.DT[, diff_in_a_from_receiver_at_pass_catch := NULL]
```

```{r include=FALSE}

# Add defender's speed and acceleration to the data model.

# add stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId,
                                playId,
                                nflId,
                                s,
                                a)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )
```

```{r include=FALSE}

# Calculate cosines of angle relative to receiver times speed (i.e., relative velocity). If defender is 180 degrees from receiver (i.e., facing opposite direction), cosine will result in -1, whereas facing receiver will result in 1.

model.DT[, o_vel := s*cos(o_relative_to_receiver*pi/180)]
model.DT[, dir_vel := s*cos(dir_relative_to_receiver*pi/180)]
```

```{r include=FALSE}
# make some columns factors
model.DT[, front_or_behind_receiver := factor(front_or_behind_receiver)]

model.DT[, should_be_tackle_factor := factor(should_be_tackle)]
```

## Find Blockers by Defender

```{r include=FALSE}

ind.blocker.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Offense" &
                            nflId != ballCarrierId,
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              blockerId = nflId,
                              blockerName = displayName,
                              blocker_x = x,
                              blocker_y = y,
                              blocker_dist_from_rec = dist_from_receiver_at_pass_catch)]

ind.defender.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Defense",
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              defenderId = nflId,
                              defenderName = displayName,
                              defender_x = x,
                              defender_y = y,
                              defender_dist_from_rec = dist_from_receiver_at_pass_catch,
                              playDirection,
                              receiver_at_pass_catch_x,
                              receiver_at_pass_catch_y)]

# merge the blocker data and defender data - WILL create duplicates and be a large data table
ind.blocker.and.defender.data <- merge(ind.blocker.data,
                                       ind.defender.data,
                                       by = c("gameId", "playId"),
                                       allow.cartesian = TRUE)

# remove
rm(ind.blocker.data)
rm(ind.defender.data)

# calculate distance between each defender and blocker
ind.blocker.and.defender.data[, blocker_dist_from_defender := sqrt((defender_x - blocker_x)^2 +
                                                             (defender_y - blocker_y)^2)]

# calculate if blocker is within radius of defender
ind.blocker.and.defender.data[, blocker_in_radius := ifelse(blocker_dist_from_rec <= defender_dist_from_rec, 1, 0)]

# calculate if blocker is between receiver and defender based on x coordinates
ind.blocker.and.defender.data[, blocker_between_def_and_rec := ifelse(blocker_x >= defender_x & blocker_x <= receiver_at_pass_catch_x, 1, 0) +
                                                               ifelse(blocker_x <= defender_x & blocker_x >= receiver_at_pass_catch_x, 1, 0)]

# impactful blocker if within radius AND between receiver and defender
ind.blocker.and.defender.data[, impactful_blocker := pmin(blocker_in_radius, blocker_between_def_and_rec)]

# add up impactful blockers by defender
impactful.blockers.summary <- ind.blocker.and.defender.data[, .(Total_Impactful_Blockers = sum(impactful_blocker)),
                                                            by = .(gameId, playId, defenderId)]
# remove
rm(ind.blocker.and.defender.data)
gc()

# impactful.blockers.summary <- merge(impactful.blockers.summary,
#                                     tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
#                                     by.x = c("gameId", "playId", "defenderId"),
#                                     by.y = c("gameId", "playId", "nflId"),
#                                     all.x = TRUE)
# 
# # change NAs to 0
# impactful.blockers.summary[is.na(should_be_tackle), should_be_tackle := 0]
# 
# ggplot(model.DT, aes(x = factor(Total_Impactful_Blockers), fill = factor(should_be_tackle))) +
#   geom_bar(position = "fill") +
#   labs(title = "Relationship between should_be_tackle and Total_Impactful_Blockers",
#        x = "should_be_tackle",
#        y = "Count") +
#   theme_minimal()

# add to model.DT
model.DT <- merge(model.DT,
                  impactful.blockers.summary,
                  by.x = c("gameId", "playId", "nflId"),
                  by.y = c("gameId", "playId", "defenderId"),
                  all.x = TRUE)

# simplify to 2 levels
model.DT[, Impactful_Blocker_Level := ifelse(Total_Impactful_Blockers == 0, "None", "1_Plus")]

model.DT[, Impactful_Blocker_Level := factor(Impactful_Blocker_Level)]

# remove
rm(impactful.blockers.summary)

```

## Rank Defenders by Distance

```{r include=FALSE}

defender.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Defense",
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              defenderId = nflId,
                              defenderName = displayName,
                              defender_x = x,
                              defender_y = y,
                              defender_dist_from_rec = dist_from_receiver_at_pass_catch)]

# Sorting by gameId, playId, and defender_dist_from_rec
defender.data <- defender.data[order(gameId, playId, defender_dist_from_rec)]

# Adding the dist_rank column
defender.data[, def_dist_rank := seq_len(.N), by = .(gameId, playId)]

# add should_be_tackle
defender.data <- merge(defender.data,
                       tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                       by.x = c("gameId", "playId", "defenderId"),
                       by.y = c("gameId", "playId", "nflId"),
                       all.x = TRUE)
# change NA to 0
defender.data[is.na(should_be_tackle), should_be_tackle := 0]

# simplify down to levels
defender.data[, def_dist_rank_level := ifelse(def_dist_rank == 1, "1",
                                        ifelse(def_dist_rank == 2, "2",
                                         ifelse(def_dist_rank == 3, "3", "4+")))]

ggplot(defender.data, aes(x = factor(def_dist_rank_level), fill = factor(should_be_tackle))) +
  geom_bar(position = "fill") +
  labs(title = "",
       x = "def_dist_rank_level",
       y = "Freq") +
  theme_minimal()

# add to model.DT
model.DT <- merge(model.DT,
                  defender.data[, .(gameId, playId, defenderId, def_dist_rank_level)],
                  by.x = c("gameId", "playId", "nflId"),
                  by.y = c("gameId", "playId", "defenderId"),
                  all.x = TRUE)

# make factor
model.DT[, def_dist_rank_level := factor(def_dist_rank_level)]

# remove
rm(defender.data)

```

# Build Predictive Model for Tackling Probability

## Determine Variables for Logistic Regression Model

```{r eval=FALSE, include=FALSE}

# plot the independent variables against the target tackle variable

# distance from receiver
dist.from.rec.plot <- ggplot(model.DT, aes(x = dist_from_receiver_at_pass_catch, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Defender's Distance from Receiver at Time of Catch",
       y = "Percentage") +
  scale_fill_manual(values = c("lightblue", "coral"), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.75, 0.75),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16), 
        axis.text.x = element_text(size = 14),    
        axis.title.x = element_text(size = 14),
        legend.box.background = element_rect(color = "black"))   

# front or behind receiver
front.behind.plot <- ggplot(model.DT, aes(x = factor(should_be_tackle), fill = factor(front_or_behind_receiver))) +
  geom_bar(position = "fill") +
  scale_x_discrete(labels = c("No", "Yes")) +
  labs(title = NULL,
       x = "Tackle Resulted") +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank()) +
  guides(fill = guide_legend(title = NULL)) +
  scale_fill_manual(values = c("lightblue", "coral")) +
  geom_text(stat = 'count', aes(label = ifelse(front_or_behind_receiver == "behind", "Behind Receiver", "In Front of Receiver")),
            position = position_fill(vjust = 0.5)) +
  theme(legend.position = "none")

# o_vel
o_vel.plot <- ggplot(model.DT, aes(x = o_vel, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Orientational Velocity",
       y = "Percentage") +
  scale_fill_manual(values = c("lightblue", "coral"), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.25, 0.75),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16), 
        axis.text.x = element_text(size = 14),    
        axis.title.x = element_text(size = 14),
        legend.box.background = element_rect(color = "black"))

# dir_vel
dir_vel.plot <- ggplot(model.DT, aes(x = dir_vel, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Directional Velocity",
       y = "Percentage") +
  scale_fill_manual(values = c("lightblue", "coral"), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.25, 0.75),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16), 
        axis.text.x = element_text(size = 14),    
        axis.title.x = element_text(size = 14),
        legend.box.background = element_rect(color = "black"))

# # show plots in a grid
# par(mfrow=c(2, 2))
# dist.from.rec.plot
# front.behind.plot
# o_vel.plot
# dir_vel.plot

# use for testing other variables
ggplot(model.DT, aes(x = factor(should_be_tackle), fill = factor(Impactful_Blocker_Level))) +
  geom_bar(position = "fill", stat = "count") +
  labs(title = NULL,
       x = "should_be_tackle",
       y = "Proportion")
  #scale_fill_manual(values = c("red", "green", "blue", "orange")) +  # Adjust colors as needed
  #coord_flip()  # Rotate the plot to make it horizontal
```

This model will focus on assigning tackling probabilities *at the time of the catch*. Below are the predictive variables in our model that can all be calculated at the time of the catch:

-   **dist_from_receiver_at_pass_catch**: The defender's distance from the receiver.

-   **front_or_behind_receiver**: Is defender in front of or behind the receiver? (Yes / No)

-   **o_vel**: The orientational velocity of the defender relative to the position of the receiver. It accounts for both speed and direction of orientation (which way the defender is facing) relative to the position of the receiver. If the defender is moving at speed 2 but facing the exact opposite direction of the receiver's position, their o_vel will be -2. On the contrary, if the defender is moving at speed 2 and facing the exact direction of the receiver's position, their o_vel will be 2. This is achieved by applying the cosine function to their relative orientation angle.

-   **dir_vel**: This is similar to the orientational velocity above, but the relative angle is derived from the defender's direction of *movement* as opposed to the direction they are facing.

-   **def_dist_rank_level:** This variable utilizes the distance of each defender from the receiver at the time of the catch, but it ranks the defenders from closest to furthest. Rank/level "1" is the closest defender, then "2" and "3", and finally level "4+" is any defender ranked 4 or higher.

-   **Impactful_Blocker_Level**: 2 levels that indicate if there are 0 impactful blockers for that defender or 1+ impactful blockers for that defender. An impactful blocker is defined when these 2 conditions are met:

    1.  The blocker is within the radius of the radius between the defender and the receiver at the time of the catch. For example, if the defender in question is 10 yards from the receiver and the blocker in question is 8 yards from the receiver, then this condition is met.

    2.  The blocker's x coordinate must be between the defender in question and the receiver. This is to help eliminate blockers who are within the radius but on the opposit side of the receiver as the defender.

There were some variables I considered and tested, but they did not add meaningful value to the model.

-   **dir_relative_to_receiver**: Direction angle relative to receiver's position (0 degrees if defender is moving toward receiver's position directly; 180 degrees if defender is moving directly opposite of the receiver's position). This variable is essentially the dir_vel variable above but missing the speed information.

-   **o_relative_to_receiver**: Orientation angle of defender relative to receiver's position (0 degrees if defender is facing receiver's position directly; 180 degrees if defender is facing directly opposite of the receiver's position).

-   **a:** The acceleration of the defender.

-   **s:** The speed of the defender. This variable was not very meaningful on its own, but it was meaningful once I combined it with relative orientation and direction information above.

Our target variable is called **should_be_tackle** and has values of 0's and 1's, where 0 represents no tackle and 1 represents a tackle.

## Splitting Data into Training and Testing

I first split my data into a training and validation set. I randomly assigned 70% of the data as the training set and the remaining 30% as the validation set. I made sure that any given play was completely contained in either set. I didn't want some defenders of a play to be in the training set and other defenders of the same play to be in the validation set. The training data has about 41K rows (11 defenders for each of 3,720 plays), and the testing data has about 17.5K rows (11 defenders for each of 1,594 plays), where each row represents each defender on each of the 5,314 passing plays that meet our criteria.

```{r include=FALSE}
library(caret)

# Set the seed for reproducibility
set.seed(123)

# we want to split the data but make sure that plays are always grouped in the same split set
# Calculate the total number of unique gameId-playId combinations
unique_combinations <- unique(model.DT[, .(gameId, playId)])
unique_combinations[, model_split_index := 1:.N]

# Calculate the number of rows to assign as "Train" and "Test"
n_total <- nrow(unique_combinations)
n_train <- round(0.7 * n_total)
n_test <- n_total - n_train
random_numbers <- sample(1:n_total, n_train, replace = FALSE)

model.DT <- merge(model.DT, unique_combinations, by = c("gameId", "playId"))
model.DT[model_split_index %in% random_numbers, model_split_group := "Train"]
model.DT[!(model_split_index %in% random_numbers), model_split_group := "Test"]

train_data <- model.DT[model_split_group == "Train"]
test_data <- model.DT[model_split_group == "Test"]
```

## Define Logistic Regression Model

```{r}

# Training model
logistic_model <- glm(should_be_tackle ~
                        # variables to include
                        dist_from_receiver_at_pass_catch +
                        front_or_behind_receiver +
                        #o_relative_to_receiver +
                        o_vel +
                        dir_vel +
                        #s +
                        a +
                        Impactful_Blocker_Level +
                        def_dist_rank_level
                        #dir_relative_to_receiver
                        ,
                      
                        data = train_data,
                        family = binomial(link = "logit"))
#logistic_model
 
# Summary
summary(logistic_model)

# run model on test data
predict_reg <- predict(logistic_model,
                       test_data, type = "response")

# add predicted results to test data
test_data[, predict_reg := NULL] # first remove existing prediction column
test_data <- cbind(test_data, predict_reg)

# test error
absolute_test_error <- sum(abs(test_data$predict_reg - test_data$should_be_tackle))
print(paste("Error on test data: ", round(absolute_test_error,2), sep=""))

results <- test_data[, .(total_actual = sum(should_be_tackle),
                         total_expected = sum(predict_reg))]
results[, ratio := total_actual / total_expected]

# now apply model to both train and testing data
predict_all <- cbind(model.DT, predict(logistic_model, model.DT, type = "response"))
# rename V2
names(predict_all)[names(predict_all) == "V2"] <- "Prediction"
predict_all[, Prediction := round(Prediction,4)]
predict_all[, abs_error := abs(Prediction - should_be_tackle)]
```

## Normalize Probabilities

```{r}
# normalized probabilities add up to 1 for each play

# see prediction totals by play
predictions.by.play <- predict_all[, .(Total_Predict_for_Play = sum(Prediction)),
                                   by = .(gameId, playId)]

predict_all <- merge(predict_all,
                     predictions.by.play,
                     by = c("gameId", "playId"))

predict_all[, Normalized_Prediction := Prediction / Total_Predict_for_Play]

# allocates additional probability to plays with small total probabilities
predict_all[, Revised_Prediction := ifelse(Total_Predict_for_Play < 1, Normalized_Prediction,
                                           Prediction)]

# check
pred.check <- predict_all[, .(Total_Predict_for_Play = sum(Normalized_Prediction)),
                                   by = .(gameId, playId)]

if (nrow(pred.check[round(Total_Predict_for_Play,0) != 1]) != 0) {
  print("Not all probabilities add up to 100%")
  UNDECLARED()
}


```

```{r include=FALSE}
# see plot of predictions vs result
ggplot(predict_all[should_be_tackle == 0], aes(x = Revised_Prediction, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.01, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Prediction",
       y = "Percentage") +
  scale_fill_manual(values = c("lightblue", "coral"), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.25, 0.75),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 16), 
        axis.text.x = element_text(size = 14),    
        axis.title.x = element_text(size = 14),
        legend.box.background = element_rect(color = "black"))
```

## Probit Regression Model

```{r include=FALSE}
# # Training model
# probit_model <- glm(should_be_tackle ~
#                         # variables to include
#                         front_or_behind_receiver +
#                         dist_from_receiver_at_pass_catch +
#                         s +
#                         a +
#                         o_relative_to_receiver,
#                       
#                         data = train_data,
#                         family = binomial(link = "probit"))
# probit_model
#  
# # Summary
# summary(probit_model)
```

## Classification and Regression Tree Model

```{r include=FALSE}
# For decision tree model
library(rpart)
# For data visualization
library(rpart.plot)

fit.tree = rpart(should_be_tackle ~
                        # variables to include
                        front_or_behind_receiver +
                        dist_from_receiver_at_pass_catch +
                        #s +
                        #a +
                        #o_relative_to_receiver +
                        #dir_relative_to_receiver
                        def_dist_rank_level +
                        Impactful_Blocker_Level
                        ,
                         data = train_data,
                         method = "class",
                         cp=0.01)

rpart.plot(fit.tree)

```

# Compare Predictions to Player Actuals

```{r include=FALSE}

act.vs.exp <- predict_all[, .(num_plays = .N,
                total_actual = sum(should_be_tackle),
                total_expected = sum(Revised_Prediction)),
            by = .(nflId, displayName)]

act.vs.exp[, ave.ratio := total_actual / total_expected]

# plot
ggplot(act.vs.exp[total_expected >= 15], aes(x = total_expected, y = total_actual, color = ave.ratio < 1)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Expected Tackles", y = "Actual Tackles") +
  xlim(0, max(act.vs.exp$total_expected)) +
  ylim(0, max(act.vs.exp$total_actual)) +
  scale_color_manual(values = c("lightgreen", "coral"),
                     labels = c("More Tackles than Expected", "Less Tackles than Expected")) +
  theme_minimal() +
  theme(legend.title = element_blank(),
        legend.position = c(0.075, 0.925),
        legend.justification = c(0, 1),
        legend.background = element_rect(fill = "transparent", color = NA),
        legend.box.background = element_rect(fill = "white", color = "black"))

print(paste("# Act < Exp: ", nrow(act.vs.exp[total_expected >= 15 & total_actual < total_expected])))
print(paste("# Act >= Exp: ", nrow(act.vs.exp[total_expected >= 15 & total_actual >= total_expected])))

print(sum(act.vs.exp$total_actual))
print(sum(act.vs.exp$total_expected))

# plot predictions
# ggplot(data = predict_all[should_be_tackle > 0], aes(x = Prediction)) +
#   geom_histogram(binwidth = (max(predict_all$Prediction) - min(predict_all$Prediction)) / 25) +
#   xlab("Prediction") +
#   ylab("Count")
```

## Compare Top 20 from Earlier

Recall we showed the top 20 players with the most passing tackles. Let's see if these players' tackles are impressive or not according to our logistic regression model. The below chart has the same 20 players as before, but it now sorts them by their actual-to-expected ratios instead of by their total tackles. We can see that most of these players do indeed perform better than expected - some more than others. The 2 exceptions who perform worse than expected are Mykal Walker and Devin Lloyd. Eddie Jackson and Jevon Holland are the best performers in the group.

```{r}
act.v.exp.top.actual <- act.vs.exp[order(-total_actual)]

act.v.exp.top.actual <- act.v.exp.top.actual[1:20]

ggplot(act.v.exp.top.actual, aes(x = ave.ratio, y = reorder(displayName, ave.ratio))) +
  geom_bar(aes(fill = ifelse(ave.ratio < 1, 'coral', 'lightgreen')), stat = "identity") +
  geom_text(aes(label = round(ave.ratio, 2)), hjust = 2, size = 3) +
  labs(title = 'Passing Tackles by Player (Top 20)',
       x = '') +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_identity()
```

Of course, this is only looking at the same 20 players we looked at before. Let's expand this. After filtering results down to players with at least 15 expected tackles (to weed out mainly lineman who have few expected tackles and few actual tackles across passing plays), below I show the 10 best actual-to-expected ratios and the 10 worst actual-to-expected ratios.

```{r}
act.v.exp.selected <- act.vs.exp[order(-ave.ratio)]
act.v.exp.selected <- act.v.exp.selected[total_expected >= 15]

act.v.exp.selected <- rbind(head(act.v.exp.selected, 10), tail(act.v.exp.selected, 10))

# add position
act.v.exp.selected <- merge(act.v.exp.selected,
                            players.DT[, .(nflId, position)],
                            by = c("nflId"))

# name + position
act.v.exp.selected[, name_and_pos := paste(displayName, " (", position, ")", sep="")]

# selected best 10 and worst 10
ggplot(act.v.exp.selected, aes(x = ave.ratio, y = reorder(name_and_pos, ave.ratio))) +
  geom_bar(aes(fill = ifelse(ave.ratio < 1, 'coral', 'lightgreen')), stat = "identity") +
  geom_text(aes(label = round(ave.ratio, 2)), hjust = 1.5, size = 2.5) +
  labs(title = '10 Best and Worst Passing Tacklers',
       subtitle = '  and their actual-to-expected tackle ratios',
       x = '') +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        plot.subtitle = element_text(size = 11, color = 'gray50', face = 'italic')) +
  scale_fill_identity()
```

We can take a closer look at some individual players and the plays in which they were involved.

```{r}
# Eddie Jackson id = 44925
# Eli Apple is = 43299
spec.player.A <- predict_all[nflId == 44925]

spec.player.A[, game_and_play := paste(gameId, playId)]

ggplot(spec.player.A, aes(x = reorder(seq_along(Revised_Prediction), -Revised_Prediction),
                          y = Revised_Prediction,
                          fill = factor(should_be_tackle))) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("lightgray", "darkgreen"), 
                    name = "Got the tackle?",
                    labels = c("No", "Yes")) +  # Set custom legend labels
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    legend.position = c(0.9, 0.9),  # Adjust legend position (top right)
    legend.justification = c(1, 1),   # Adjust legend justification (top right)
    legend.box.background = element_rect(color = "black"),  # Add legend border
    legend.box.margin = margin(t = 1, r = 1)  # Adjust margin around legend
  ) +
  labs(y = "Modeled Probability", fill = "Got the tackle?") +
  ggtitle("Eddie Jackson's Plays")
```

Notes for self:

-   Check actually recorded missed tackles for some key players

-   Can we incorporate missed tackles somehow? We need to distinguish missed tackles against the QB or other compared to the target receiver.
