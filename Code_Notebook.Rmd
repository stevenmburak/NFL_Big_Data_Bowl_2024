# Data Cleansing and Structuring

```{r Setup, include=FALSE}

# load libraries
library(dplyr, quietly = TRUE)
library(data.table, quietly = TRUE)
library(RSQLite, quietly = TRUE)
library(ggplot2, quietly = TRUE)

# connect to SQLite DB
# I've stored all the tracking data as one data table in SQLite
sqlite_con <- dbConnect(RSQLite::SQLite(), dbname = "sqlite_data/nfl.db")

# load key data tables. tracking is NOT loaded here, as it's huge. we'll load a subset of that later
tackles.DT <- as.data.table(readRDS("rds_data/tackles.rds"))
plays.DT <- as.data.table(readRDS("rds_data/plays.rds"))
games.DT <- as.data.table(readRDS("rds_data/games.rds"))
players.DT <- as.data.table(readRDS("rds_data/players.rds"))


# color styling
my.green <- "#50C878"	  #"#0f8a59"
my.red <- "#EC5800"
```

```{r Plays_of_Interest, include=FALSE}

# assign should_be_tackle
# equals 1 for any tackle, assist, or forced fumble
tackles.DT[, should_be_tackle := ifelse(1*tackle + 1*assist + 1*forcedFumble + 0*pff_missedTackle > 0, 1, 0)]

# determine plays that have a should_be_tackle event
should.be.tackle.plays <- unique(tackles.DT[should_be_tackle == 1, .(gameId, playId)])

# load plays data
plays.DT <- as.data.table(readRDS("rds_data/plays.rds"))

# determine passing plays using the completed pass indicator from the plays data
# incomplete pass obviously won't result in a should-be-tackle event
# scrambles are considered run plays in this context
# and blanks are either running plays or non-interests
passing.plays <- unique(plays.DT[passResult == "C", .(gameId, playId)])

# we can now inner join our passing plays and should-be-tackle plays to get our list of passing plays that resulted in a should-be-tackle event
plays.of.interest <- merge(should.be.tackle.plays,
                           passing.plays,
                           by = c("gameId", "playId"))
# remove uneeded data
rm(should.be.tackle.plays)
rm(passing.plays)

# write to our SQLite database
dbWriteTable(sqlite_con, name = "plays_of_interest", value = plays.of.interest, overwrite = TRUE)
```

```{sql Grab_Tracking_Data, connection=sqlite_con, output.variable = "tracking.DT"}

-- grab the tracking data only for the plays of interest

SELECT
  tracking_all.*

FROM tracking_all -- all tracking data INNER JOINed with our subset of plays
  INNER JOIN plays_of_interest ON (tracking_all.gameId = plays_of_interest.gameId AND 
                                    tracking_all.playId = plays_of_interest.playId)
                                    
--WHERE
  -- stick to one game and play for now for testing purposes; expand later
  --tracking_all.gameId = 2022090800
  --AND tracking_all.playId = 122
  
ORDER BY
  tracking_all.gameId,
  tracking_all.playId,
  tracking_all.frameId

```

```{r Manipulate_Tracking_Data, include=FALSE}

# We need to make a few additions and manipulations to the tracking data.

tracking.DT <- as.data.table(tracking.DT)

# We need to add a simple field to the tracking data to indicate which team is on offense or defense
# re-structure the plays data to flag offsensive vs defensive team
off.def.teams.by.play <- melt(plays.DT, measure.vars = c("possessionTeam", "defensiveTeam"))
setnames(off.def.teams.by.play, "value", "Team")
off.def.teams.by.play[, Off_or_Def := ifelse(variable == "possessionTeam", "Offense", "Defense")]
off.def.teams.by.play <- off.def.teams.by.play[, .(gameId, playId, Team, Off_or_Def)]

# join the Off_or_Def indicator to our tracking data
tracking.DT <- merge(tracking.DT,
                     off.def.teams.by.play,
                     by.x = c("gameId", "playId", "club"),
                     by.y = c("gameId", "playId", "Team"),
                     all.x = TRUE)

# remove off.vs.def data
rm(off.def.teams.by.play)
```

```{r include=FALSE}

# want to add a field to the tracking data that shows if the player was the player (or one of the players) that got the tackle. this will be useful for our animations

tracking.DT <- merge(tracking.DT,
                     tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                     by = c("gameId", "playId", "nflId"),
                     all.x = TRUE)

tracking.DT[is.na(should_be_tackle), should_be_tackle := 0]
```

```{r Start_Building_Model_Data, include=FALSE}

# Start building the model database of predictive variables and the target variable.

model.DT <- unique(tracking.DT[Off_or_Def == "Defense", # only want defensive players in the model
                        .(gameId,
                          playId,
                          nflId,
                          displayName)])
```

```{r Add_Should_be_Tackles, include=FALSE}

# Start adding key stats to the model data.

# Add indicator if player had a should-be-tackle.

model.DT <- merge(model.DT,
                  tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE)

# change NAs to 0
model.DT[is.na(should_be_tackle), should_be_tackle := 0]

```

## Simple Actuals

It's worth pausing here, as we now have a database of each player and how many tackles (remember, tackle here means a tackle, assist, or a forced fumble) they made across the 9 weeks of data. We'll see how these raw tackle counts - unadjusted for situational context - stack up against our final model.

```{r echo=FALSE}
# show top 20 actual tackle players
simple.tackles.by.player <- model.DT[, .(Tackles = sum(should_be_tackle)), by = .(nflId, displayName)]
simple.tackles.by.player[, name_plus_id := paste(displayName, " (nflId ", nflId, ")", sep="")]

# add position
simple.tackles.by.player <- merge(simple.tackles.by.player,
                                  players.DT[, .(nflId, position)],
                                  by = c("nflId"))

# name + position
simple.tackles.by.player[, name_and_pos := paste(displayName, " (", position, ")", sep="")]

simple.tackles.by.player <- simple.tackles.by.player[order(-Tackles)]
simple_top_players <- simple.tackles.by.player[1:20]

#

ggplot(simple_top_players, aes(x = Tackles, y = reorder(name_and_pos, Tackles))) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_text(aes(label = Tackles), hjust = 1.5, size = 3) +
  labs(title = 'Passing Tackles by Player (Top 20)',
       x = '') +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank())
```

## Feature Engineering

```{r Ball_Carrier_Data, include=FALSE}

# start adding variables to the model

# add ball Carrier to tracking data
tracking.DT <- merge(tracking.DT,
                     plays.DT[, .(gameId, playId, ballCarrierId)],
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# calculate receiver coordinates and play direction at time of pass catch
receiver.coordinates.at.catch <- tracking.DT[nflId == ballCarrierId & event == "pass_outcome_caught",
                                                     .(gameId,
                                                       playId,
                                                       # rename column for easier joining later
                                                       receiver_at_pass_catch_x = x,
                                                       # rename column for easier joining later
                                                       receiver_at_pass_catch_y = y)
                                                   ]

# join receiver coordinates to tracking data
tracking.DT <- merge(tracking.DT,
                     receiver.coordinates.at.catch,
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# can remove receiver coordinates at time of pass catch temporary data table
rm(receiver.coordinates.at.catch)

# calculate if player is between receiver and endzone at time of catch
tracking.DT[, front_or_behind_receiver := ifelse(playDirection == "left", 
        ifelse(x <= receiver_at_pass_catch_x, "front", "behind"),
        ifelse(x > receiver_at_pass_catch_x, "front", "behind"))]

# calculate distance from receiver
tracking.DT[, dist_from_receiver_at_pass_catch := sqrt((x - receiver_at_pass_catch_x)^2 + 
                                                           (y - receiver_at_pass_catch_y)^2)]

# load our geometry functions defined in a separate script
source("geometry_functions.R")

# calculate orientation angle relative to position of receiver
tracking.DT[, o_relative_to_receiver := angle_relative_to_point(x,
                                                                y,
                                                                o,
                                                                receiver_at_pass_catch_x,
                                                                receiver_at_pass_catch_y)]

# calculate direction angle relative to position of receiver
tracking.DT[, dir_relative_to_receiver := angle_relative_to_point(x,
                                                                y,
                                                                dir,
                                                                receiver_at_pass_catch_x,
                                                                receiver_at_pass_catch_y)]


# add calculated stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId, playId, nflId,
                                front_or_behind_receiver,
                                dist_from_receiver_at_pass_catch,
                                o_relative_to_receiver,
                                dir_relative_to_receiver
                                )],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )

```

### Proximity to Sideline Calcs

```{r}
# proximity to sideline data
tracking.DT[, receiver_y_revised := ifelse(receiver_at_pass_catch_y < 0, 0,
                                      ifelse(receiver_at_pass_catch_y > 53.3, 53.3,
                                         receiver_at_pass_catch_y))]

tracking.DT[, receiver_dist_from_sideline := ifelse(receiver_y_revised < 53.3/2,
                                                    receiver_y_revised - 0,
                                                    53.3 - receiver_y_revised)]

tracking.DT[, y_revised := ifelse(y < 0, 0,
                                      ifelse(y > 53.3, 53.3,
                                         y))]


tracking.DT[, dist_from_receivers_sideline := ifelse(receiver_y_revised < 53.3/2,
                                                    y_revised - 0,
                                                    53.3 - y_revised)]

# equals 1 if defender is further from receiver's sideline than receiver, 0 if not
# idea here is that if defender is further, they have opportunity to push receiver out of bounds
tracking.DT[, in_ideal_sideline_pos := ifelse(dist_from_receivers_sideline > receiver_dist_from_sideline, 1, 0)]

# sideline position index
# idea here is that the defender will get a high sideline position index (good thing) if they are further from the receiver's sideline than the receiver AND if the receiver is close to the sideline
tracking.DT[, sideline_position_index := ifelse(receiver_dist_from_sideline == 0, in_ideal_sideline_pos, in_ideal_sideline_pos / receiver_dist_from_sideline)]


# add calculated stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId, playId, nflId,
                                receiver_dist_from_sideline,
                                in_ideal_sideline_pos,
                                sideline_position_index)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )
```

### Relative Angles and Movement Calculations

```{r Add_Angle_Direction_Data, include=FALSE}

# Add difference in angle of direction and angle of orientation from receiver at time of catch.

# calculate receiver direction angle and at time of pass catch
receiver.angles.at.catch <- tracking.DT[nflId == ballCarrierId &
                                        event == "pass_outcome_caught",
                                         .(gameId,
                                           playId,
                                           # rename columns for easier joining later
                                           receiver_at_pass_catch_o = o,
                                           receiver_at_pass_catch_dir = dir,
                                           receiver_at_pass_catch_s = s,
                                           receiver_at_pass_catch_a = a)
                                       ]

# join receiver angles data to tracking data
tracking.DT <- merge(tracking.DT,
                     receiver.angles.at.catch,
                     by = c("gameId", "playId"),
                     all.x = TRUE)

# can remove receiver coordinates at time of pass catch
rm(receiver.angles.at.catch)

# calculate angle and speed differences from receiver
# orientation angle (take absolute degree difference)
tracking.DT[, diff_in_o_from_receiver_at_pass_catch := abs(o - receiver_at_pass_catch_o)]
tracking.DT[, diff_in_o_from_receiver_at_pass_catch := ifelse(diff_in_o_from_receiver_at_pass_catch > 180, 360 - diff_in_o_from_receiver_at_pass_catch, diff_in_o_from_receiver_at_pass_catch)]

# direction angle (take absolute degree difference)
tracking.DT[, diff_in_dir_from_receiver_at_pass_catch := abs(dir - receiver_at_pass_catch_dir)]
tracking.DT[, diff_in_dir_from_receiver_at_pass_catch := ifelse(diff_in_dir_from_receiver_at_pass_catch > 180, 360 - diff_in_dir_from_receiver_at_pass_catch, diff_in_dir_from_receiver_at_pass_catch)]

# speed and acceleration (don't take absolute difference)
tracking.DT[, diff_in_s_from_receiver_at_pass_catch := s - receiver_at_pass_catch_s]
tracking.DT[, diff_in_a_from_receiver_at_pass_catch := a - receiver_at_pass_catch_a]

# add stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId,
                                playId,
                                nflId,
                                diff_in_o_from_receiver_at_pass_catch,
                                diff_in_dir_from_receiver_at_pass_catch,
                                diff_in_s_from_receiver_at_pass_catch,
                                diff_in_a_from_receiver_at_pass_catch,
                                receiver_at_pass_catch_s,
                                receiver_at_pass_catch_a)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )

```

```{r include=FALSE}

# Add defender's speed and acceleration to the data model.

# add stats to model data
model.DT <- merge(model.DT,
                  tracking.DT[event == "pass_outcome_caught",
                              .(gameId,
                                playId,
                                nflId,
                                s,
                                a)],
                  by = c("gameId", "playId", "nflId"),
                  all.x = TRUE
                  )
```

```{r include=FALSE}

# Calculate cosines of angle relative to receiver times speed (i.e., relative velocity). If defender is 180 degrees from receiver (i.e., facing opposite direction), cosine will result in -1, whereas facing receiver will result in 1.

model.DT[, o_vel := s*cos(o_relative_to_receiver*pi/180)]
model.DT[, dir_vel := s*cos(dir_relative_to_receiver*pi/180)]
```

```{r include=FALSE}
# make some columns factors
model.DT[, front_or_behind_receiver := factor(front_or_behind_receiver)]
model.DT[, should_be_tackle_factor := factor(should_be_tackle)]
model.DT[, in_ideal_sideline_pos := factor(in_ideal_sideline_pos)]
```

### Find Blockers by Defender

```{r include=FALSE}

ind.blocker.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Offense" &
                            nflId != ballCarrierId,
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              blockerId = nflId,
                              blockerName = displayName,
                              blocker_x = x,
                              blocker_y = y,
                              blocker_dist_from_rec = dist_from_receiver_at_pass_catch)]

ind.defender.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Defense",
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              defenderId = nflId,
                              defenderName = displayName,
                              defender_x = x,
                              defender_y = y,
                              defender_dist_from_rec = dist_from_receiver_at_pass_catch,
                              playDirection,
                              receiver_at_pass_catch_x,
                              receiver_at_pass_catch_y)]

# merge the blocker data and defender data - WILL create duplicates and be a large data table
ind.blocker.and.defender.data <- merge(ind.blocker.data,
                                       ind.defender.data,
                                       by = c("gameId", "playId"),
                                       allow.cartesian = TRUE)

# remove
rm(ind.blocker.data)
rm(ind.defender.data)

# calculate distance between each defender and blocker
ind.blocker.and.defender.data[, blocker_dist_from_defender := sqrt((defender_x - blocker_x)^2 +
                                                             (defender_y - blocker_y)^2)]

# calculate if blocker is within radius of defender
ind.blocker.and.defender.data[, blocker_in_radius := ifelse(blocker_dist_from_rec <= defender_dist_from_rec, 1, 0)]

# calculate if blocker is between receiver and defender based on x coordinates
ind.blocker.and.defender.data[, blocker_between_def_and_rec := ifelse(blocker_x >= defender_x & blocker_x <= receiver_at_pass_catch_x, 1, 0) +
                                                               ifelse(blocker_x <= defender_x & blocker_x >= receiver_at_pass_catch_x, 1, 0)]

# impactful blocker if within radius AND between receiver and defender
ind.blocker.and.defender.data[, impactful_blocker := pmin(blocker_in_radius, blocker_between_def_and_rec)]

# add up impactful blockers by defender
impactful.blockers.summary <- ind.blocker.and.defender.data[, .(Total_Impactful_Blockers = sum(impactful_blocker)),
                                                            by = .(gameId, playId, defenderId)]
# remove
rm(ind.blocker.and.defender.data)
gc()

# add to model.DT
model.DT <- merge(model.DT,
                  impactful.blockers.summary,
                  by.x = c("gameId", "playId", "nflId"),
                  by.y = c("gameId", "playId", "defenderId"),
                  all.x = TRUE)

# simplify to 2 levels
model.DT[, Impactful_Blocker_Level := ifelse(Total_Impactful_Blockers == 0, "None", "1_Plus")]

model.DT[, Impactful_Blocker_Level := factor(Impactful_Blocker_Level)]

# remove
rm(impactful.blockers.summary)

```

### Rank Defenders by Distance

```{r include=FALSE}

defender.data <- tracking.DT[#gameId == 2022100208 & playId == 1303 & # temporary for testing
                            event == "pass_outcome_caught" &
                            Off_or_Def == "Defense",
                            
                            .(gameId, playId,
                              # rename some columns for easier merging
                              defenderId = nflId,
                              defenderName = displayName,
                              defender_x = x,
                              defender_y = y,
                              defender_dist_from_rec = dist_from_receiver_at_pass_catch)]

# Sorting by gameId, playId, and defender_dist_from_rec
defender.data <- defender.data[order(gameId, playId, defender_dist_from_rec)]

# Adding the dist_rank column
defender.data[, def_dist_rank := seq_len(.N), by = .(gameId, playId)]

# add should_be_tackle
defender.data <- merge(defender.data,
                       tackles.DT[, .(gameId, playId, nflId, should_be_tackle)],
                       by.x = c("gameId", "playId", "defenderId"),
                       by.y = c("gameId", "playId", "nflId"),
                       all.x = TRUE)
# change NA to 0
defender.data[is.na(should_be_tackle), should_be_tackle := 0]

# simplify down to levels
defender.data[, def_dist_rank_level := ifelse(def_dist_rank == 1, "1",
                                        ifelse(def_dist_rank == 2, "2",
                                         ifelse(def_dist_rank == 3, "3", "4+")))]

# add to model.DT
model.DT <- merge(model.DT,
                  defender.data[, .(gameId, playId, defenderId, def_dist_rank_level)],
                  by.x = c("gameId", "playId", "nflId"),
                  by.y = c("gameId", "playId", "defenderId"),
                  all.x = TRUE)

# make factor
model.DT[, def_dist_rank_level := factor(def_dist_rank_level)]

# remove
rm(defender.data)

```

# Build Predictive Model for Tackling Probability

## Plots of Independent Variables

```{r eval=FALSE, include=FALSE}

# plot the independent variables against the target tackle variable

yes.color <- my.green
no.color <- "lightgray"

# distance from receiver
ggplot(model.DT, aes(x = dist_from_receiver_at_pass_catch, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Defender's Distance from Receiver at Time of Catch",
       y = "Frequency") +
  scale_fill_manual(values = c(no.color, yes.color), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(#axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.75, 0.75),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12), 
        axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.box.background = element_rect(color = "black"))  

# defender distance rank
ggplot(model.DT, aes(x = factor(def_dist_rank_level), fill = factor(should_be_tackle))) +
  geom_bar(position = "fill") +
  labs(title = "",
       x = "Defender's Distance from Receiver Rank",
       y = "Frequency") +
  theme_minimal() +
  theme(#axis.text.x = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.y = element_blank()) +
  scale_fill_manual(name = "Tackle Resulted",
                    values = c("0" = no.color, "1" = yes.color),
                    labels = c("No", "Yes")) +
  theme(legend.position = c(0.5, 1), legend.justification = c(0.5, 1), legend.box.just = "center", 
        legend.box.background = element_rect(color = "black"),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12), 
        axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12))

# front or behind receiver
ggplot(model.DT, aes(x = factor(should_be_tackle), fill = factor(front_or_behind_receiver))) +
  geom_bar(position = "fill") +
  scale_x_discrete(labels = c("No", "Yes")) +
  labs(title = NULL,
       x = "Tackle Resulted",
       y = "Frequency") +
  theme_minimal() +
  theme(#axis.title.y = element_blank(),
        #axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        #panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12), 
        axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12)) +
  guides(fill = guide_legend(title = NULL)) +
  scale_fill_manual(values = c(no.color, yes.color)) +
  geom_text(stat = 'count', aes(label = ifelse(front_or_behind_receiver == "behind", "Behind Receiver", "In Front of Receiver")),
            position = position_fill(vjust = 0.5)) +
  theme(legend.position = "none")

# dir_vel
ggplot(model.DT, aes(x = dir_vel, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.5, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Directional Velocity",
       y = "Frequency") +
  scale_fill_manual(values = c(no.color, yes.color), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(#axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.25, 0.75),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12), 
        axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.box.background = element_rect(color = "black"))


# angle vs dir_vel
ggplot(model.DT, aes(x = dir_relative_to_receiver, y = dir_vel)) +
  geom_point(size = 0.4, color = "lightgray") + 
  geom_vline(xintercept = 90, linetype = "dashed", color = "red") +
  geom_text(aes(x = 90, y = -7.5, label = "90 Degrees"), 
            vjust = 0, hjust = 0.5, color = "red") +
  labs(x = "Angle of Direction Relative to Receiver's Position",
       y = "Directional Velocity") +
  theme_minimal() +
  theme(axis.title.x = element_text(size = 12, margin = margin(t = 10)))

# impactful blockers
ggplot(model.DT, aes(x = factor(Impactful_Blocker_Level),
                     fill = factor(should_be_tackle))) +
  geom_bar(position = "fill") +
  labs(title = "",
       x = "Impactful Blocker Level",
       y = "Frequency") +
  theme_minimal() +
  theme(#axis.text.x = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.y = element_blank(),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 12), 
    axis.text.x = element_text(size = 12),    
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12)) +
  scale_fill_manual(name = "Tackle Resulted",
                    values = c("0" = no.color, "1" = yes.color),
                    labels = c("No", "Yes")) +
  scale_x_discrete(labels = c("1 or More", "Zero")) +
  theme(legend.position = c(0.5, 1), legend.justification = c(0.5, 1), legend.box.just = "center", 
        legend.box.background = element_rect(color = "black"))

# receiver distance from sideline
ggplot(model.DT, aes(x = receiver_dist_from_sideline, fill = factor(should_be_tackle))) +
  geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.2, position = "identity", alpha = 0.7) +
  labs(title = NULL,
       x = "Receiver's Distance from Nearest Sideline",
       y = "Frequency") +
  scale_fill_manual(values = c(no.color, yes.color), name = "Tackle Resulted",
                    labels = c("0" = "No", "1" = "Yes")) +
  theme_minimal() +
  theme(#axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = c(0.1, 0.8),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12), 
        axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.box.background = element_rect(color = "black"))


```

## Splitting Data into Training and Testing

```{r include=FALSE}
library(caret)

# Set the seed for reproducibility
set.seed(123)

# we want to split the data but make sure that plays are always grouped in the same split set
# Calculate the total number of unique gameId-playId combinations
unique_combinations <- unique(model.DT[, .(gameId, playId)])
unique_combinations[, model_split_index := 1:.N]

# Calculate the number of rows to assign as "Train" and "Test"
n_total <- nrow(unique_combinations)
n_train <- round(0.7 * n_total)
n_test <- n_total - n_train
random_numbers <- sample(1:n_total, n_train, replace = FALSE)

model.DT <- merge(model.DT, unique_combinations, by = c("gameId", "playId"))
model.DT[model_split_index %in% random_numbers, model_split_group := "Train"]
model.DT[!(model_split_index %in% random_numbers), model_split_group := "Test"]

train_data <- model.DT[model_split_group == "Train"]
test_data <- model.DT[model_split_group == "Test"]
```

## Define Logistic Regression Model

```{r}
# define model call function depending on training data selected
log_model_call <- function(which_data) {
  model.to.return <- glm(should_be_tackle ~
                        # variables to include
                        dist_from_receiver_at_pass_catch +
                        front_or_behind_receiver +
                        #o_relative_to_receiver +
                        #o_vel +
                        dir_vel +
                        #s +
                        #a +
                        Impactful_Blocker_Level +
                        def_dist_rank_level +
                        receiver_dist_from_sideline
                        #receiver_at_pass_catch_s
                        ,
                        data = which_data,
                        family = binomial(link = "logit"))
  
  return(model.to.return)
}

# Training model
logistic_model <- log_model_call(which_data = train_data)
 
# Summary
summary(logistic_model)

# run model on test data
predict_reg <- predict(logistic_model,
                       test_data, type = "response")

# add predicted results to test data
test_data[, predict_reg := NULL] # first remove existing prediction column
test_data <- cbind(test_data, predict_reg)

# test error
absolute_test_error <- sum(abs(test_data$predict_reg - test_data$should_be_tackle))
print(paste("Error on test data: ", round(absolute_test_error,2), sep=""))

results <- test_data[, .(total_actual = sum(should_be_tackle),
                         total_expected = sum(predict_reg))]
results[, ratio := total_actual / total_expected]

print(paste("AvE Ratio: ", results$ratio))
```

## Re-Train Model with All Data

```{r}
# train with all data
logistic_model <- log_model_call(which_data = model.DT)

summary(logistic_model)


# now apply model to both train and testing data
predict_all <- cbind(model.DT, predict(logistic_model, model.DT, type = "response"))
# rename V2
names(predict_all)[names(predict_all) == "V2"] <- "Prediction"
predict_all[, Prediction := round(Prediction,4)]
predict_all[, abs_error := abs(Prediction - should_be_tackle)]
```

## Normalize and Fine-Tune Probabilities

```{r}
# normalized probabilities add up to 1 for each play

# see prediction totals by play
predictions.by.play <- predict_all[, .(Total_Predict_for_Play = sum(Prediction)),
                                   by = .(gameId, playId)]

predict_all <- merge(predict_all,
                     predictions.by.play,
                     by = c("gameId", "playId"))

predict_all[, Normalized_Prediction := Prediction / Total_Predict_for_Play]

# allocates additional probability to plays with small total probabilities
predict_all[, Revised_Prediction := ifelse(Total_Predict_for_Play < 1, Normalized_Prediction,
                                           Prediction)]

# check
pred.check <- predict_all[, .(Total_Predict_for_Play = sum(Normalized_Prediction)),
                                   by = .(gameId, playId)]

if (nrow(pred.check[round(Total_Predict_for_Play,0) != 1]) != 0) {
  print("Not all probabilities add up to 100%")
  UNDECLARED()
}

# allocating low probabilities to higher players
low.prob.threshold <- .05
predict_all[, Low_Prob := ifelse(Revised_Prediction < low.prob.threshold, "Y", "N")]

low.probs.to.allocate <- predict_all[Low_Prob == "Y",
                                           .(Total_Low_Prob = sum(Revised_Prediction),
                                             Low_Prob_Ct = .N),
                                           by = .(gameId, playId)]

predict_all <- merge(predict_all,
                     low.probs.to.allocate,
                     by = c("gameId", "playId"),
                     # keep all plays as some won't be in the low prob data
                     all.x = TRUE)

# change NAs to 0
predict_all[is.na(Total_Low_Prob), Total_Low_Prob := 0]
predict_all[is.na(Low_Prob_Ct), Low_Prob_Ct := 0]

# sum total revised prediction for each play
total.probs <- predict_all[, .(Total_Revised_Prediction_for_Play = sum(Revised_Prediction)),
                           by = .(gameId, playId)]

predict_all <- merge(predict_all,
                     total.probs,
                     by = c("gameId", "playId"),
                     all.x = TRUE)

predict_all[, Allocated_Prediction := ifelse(Low_Prob == "Y", 0, # low probs get 0% prediction
    # otherwise, allocate the total low probability needing to be allocated based on the ratio that each high probability defender contributes to the high probability total                                     
    Revised_Prediction + (Total_Low_Prob * Revised_Prediction / (Total_Revised_Prediction_for_Play - Total_Low_Prob)))]

# cap at 99%
predict_all[, Allocated_Prediction := ifelse(Allocated_Prediction > 0.99, 0.99, Allocated_Prediction)]
```

## Plot All Plays

```{r eval=FALSE, include=FALSE}
# plot each play's probability and whether or not a tackle resulted
ggplot(predict_all[Allocated_Prediction >= 0.05], aes(x = reorder(seq_along(Allocated_Prediction), -Allocated_Prediction),
                          y = Allocated_Prediction,
                          fill = factor(should_be_tackle))) +
  geom_bar(stat = "identity", position = "identity") +  # Remove the gap between bars
  scale_fill_manual(values = c("lightgray", my.green), 
                    name = "Tackle Resulted",
                    labels = c("No", "Yes")) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 12), 
    #axis.text.x = element_text(size = 12),    
    #axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.position = c(0.9, 0.9),
    legend.justification = c(1, 1),
    legend.box.background = element_rect(color = "black"),
    legend.box.margin = margin(t = 1, r = 1)
  ) +
  labs(y = "Modeled Probability", fill = "Tackle Resulted")
```

## Example Play

```{r}
# gameId == 2022092200 & playId == 3053

example.play <- predict_all[gameId == 2022092200 & playId == 3053]

# add jersey number
example.play <- merge(example.play,
                      unique(tracking.DT[,.(gameId, playId, nflId, jerseyNumber)]),
                      by = c("gameId", "playId", "nflId"))

example.play <- example.play[order(-example.play$Allocated_Prediction)]
                             
#write.csv(example.play, "images_for_submission/example.play.csv")

```

```{r eval=FALSE, include=FALSE}
# # see plot of predictions vs result
# ggplot(predict_all[should_be_tackle == 0], aes(x = Revised_Prediction, fill = factor(should_be_tackle))) +
#   geom_histogram(aes(y = after_stat(count / sum(count))), binwidth = 0.01, position = "identity", alpha = 0.7) +
#   labs(title = NULL,
#        x = "Prediction",
#        y = "Percentage") +
#   scale_fill_manual(values = c("lightblue", "coral"), name = "Tackle Resulted",
#                     labels = c("0" = "No", "1" = "Yes")) +
#   theme_minimal() +
#   theme(axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         panel.grid.major.y = element_blank(),
#         panel.grid.minor.y = element_blank(),
#         legend.position = c(0.25, 0.75),
#         legend.text = element_text(size = 16),
#         legend.title = element_text(size = 16), 
#         axis.text.x = element_text(size = 14),    
#         axis.title.x = element_text(size = 14),
#         legend.box.background = element_rect(color = "black"))
```

### Probit Regression Model

```{r include=FALSE}
# # Training model
# probit_model <- glm(should_be_tackle ~
#                         # variables to include
#                         front_or_behind_receiver +
#                         dist_from_receiver_at_pass_catch +
#                         s +
#                         a +
#                         o_relative_to_receiver,
#                       
#                         data = train_data,
#                         family = binomial(link = "probit"))
# probit_model
#  
# # Summary
# summary(probit_model)
```

## Classification and Regression Tree Model

```{r include=FALSE}
# For decision tree model
library(rpart)
# For data visualization
library(rpart.plot)

fit.tree = rpart(should_be_tackle ~
                        # variables to include
                        front_or_behind_receiver +
                        dist_from_receiver_at_pass_catch +
                        #s +
                        #a +
                        #o_relative_to_receiver +
                        #dir_relative_to_receiver
                        def_dist_rank_level +
                        Impactful_Blocker_Level
                        ,
                         data = model.DT,
                         method = "class",
                         cp=0.01)

rpart.plot(fit.tree)

```

# Results

## Compare Predictions to Player Actuals

```{r include=FALSE}

show.expected.threshold <- 15

act.vs.exp <- predict_all[, .(num_plays = .N,
                total_actual = sum(should_be_tackle),
                total_expected = sum(Allocated_Prediction)),
            by = .(nflId, displayName)]

act.vs.exp[, ave.ratio := total_actual / total_expected]

# add position
act.vs.exp <- merge(act.vs.exp,
                    players.DT[, .(nflId, position)],
                    by = c("nflId"))

# name + position
act.vs.exp[, name_and_pos := paste(displayName, " (", position, ")", sep="")]

# plot
ggplot(act.vs.exp[total_expected >= show.expected.threshold], aes(x = total_expected, y = total_actual, color = ave.ratio < 1)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(x = "Expected Tackles", y = "Actual Tackles") +
  xlim(10, max(act.vs.exp$total_expected)) +
  ylim(10, max(act.vs.exp$total_actual)) +
  scale_color_manual(values = c(my.green, my.red),
                     labels = c("More Tackles than Expected", "Less Tackles than Expected")) +
  theme_minimal() +
  theme(legend.title = element_blank(),
        legend.position = c(0.01, 0.925),
        legend.justification = c(0, 1),
        legend.background = element_rect(fill = "transparent", color = NA),
        legend.box.background = element_rect(fill = "white", color = "black"),
        legend.text = element_text(size = 9),
        #legend.title = element_text(size = 12), 
        #axis.text.x = element_text(size = 12),    
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12))

print(paste("# Act < Exp: ", nrow(act.vs.exp[total_expected >= show.expected.threshold & total_actual < total_expected])))
print(paste("# Act >= Exp: ", nrow(act.vs.exp[total_expected >= show.expected.threshold & total_actual >= total_expected])))

print(sum(act.vs.exp$total_actual))
print(sum(act.vs.exp$total_expected))

# plot predictions
# ggplot(data = predict_all[should_be_tackle > 0], aes(x = Prediction)) +
#   geom_histogram(binwidth = (max(predict_all$Prediction) - min(predict_all$Prediction)) / 25) +
#   xlab("Prediction") +
#   ylab("Count")
```

## Compare Top 20 from Earlier

```{r}
act.v.exp.top.actual <- act.vs.exp[order(-total_actual)]

act.v.exp.top.actual <- act.v.exp.top.actual[1:20]

ggplot(act.v.exp.top.actual, aes(x = ave.ratio, y = reorder(name_and_pos, total_actual))) +
  geom_bar(aes(fill = ifelse(ave.ratio < 1, my.red, my.green)), stat = "identity") +
  geom_text(aes(label = round(ave.ratio, 2)), hjust = 2, vjust = 0.35, size = 3) +
  labs(title = 'AvE Ratios for 20 Players with Most Actual Tackles',
       x = NULL) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank()) +
  scale_fill_identity()
```

## Best and Worst 10

```{r}
act.v.exp.selected <- act.vs.exp[order(-ave.ratio)]
# only consider those with at least 15 expected
act.v.exp.selected <- act.v.exp.selected[total_expected >= show.expected.threshold]

act.v.exp.selected <- rbind(head(act.v.exp.selected, 10), tail(act.v.exp.selected, 10))

# selected best 10 and worst 10
ggplot(act.v.exp.selected, aes(x = ave.ratio, y = reorder(name_and_pos, ave.ratio))) +
  geom_bar(aes(fill = ifelse(ave.ratio < 1, my.red, my.green)), stat = "identity") +
  geom_text(aes(label = sprintf("%.2f", ave.ratio)), hjust = 1.5, vjust = 0.35, size = 3) +
  labs(title = '10 Best and Worst Passing Tacklers',
       subtitle = '  and their AvE Ratios',
       x = NULL) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        plot.subtitle = element_text(size = 11, color = 'gray50', face = 'italic')) +
  scale_fill_identity()
```

## Eddie Jackson Plays

```{r}
# Eddie Jackson id = 44925
spec.player.A <- predict_all[nflId == 44925]

ggplot(spec.player.A, aes(x = reorder(seq_along(Allocated_Prediction), -Allocated_Prediction),
                          y = Allocated_Prediction,
                          color = factor(should_be_tackle))) +
  geom_point(position = position_dodge(width = 0.75), size = 1.5) +  # Adjust the width as needed
  scale_color_manual(values = c("lightgray", "darkgreen"), 
                     name = "Tackle Resulted",
                     labels = c("No", "Yes")) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    legend.position = c(0.9, 0.9),
    legend.justification = c(1, 1),
    legend.box.background = element_rect(color = "black"),
    legend.box.margin = margin(t = 1, r = 1)
  ) +
  labs(y = "Modeled Probability", color = "Tackle Resulted") +
  ggtitle("Eddie Jackson's Plays") +
  ylim(0, 1)
```

## Eli Apple Plays

```{r}
# Eli Apple is = 43299
spec.player.B <- predict_all[nflId == 43299]

ggplot(spec.player.B, aes(x = reorder(seq_along(Allocated_Prediction), -Allocated_Prediction),
                          y = Allocated_Prediction,
                          color = factor(should_be_tackle))) +
  geom_point(position = position_dodge(width = 0.75), size = 1.5) +  # Adjust the width as needed
  scale_color_manual(values = c("lightgray", "darkgreen"), 
                     name = "Tackle Resulted",
                     labels = c("No", "Yes")) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    legend.position = c(0.9, 0.9),
    legend.justification = c(1, 1),
    legend.box.background = element_rect(color = "black"),
    legend.box.margin = margin(t = 1, r = 1)
  ) +
  labs(y = "Modeled Probability", color = "Tackle Resulted") +
  ggtitle("Eli Apple's Plays") +
  ylim(0, 1)
```

# Write App Data

```{r eval=FALSE, include=FALSE}

# chunk needs to be manually run, does not run by default

players.for.app <- act.vs.exp[total_expected >= 15, .(nflId)]

write.app.data <- merge(predict_all,
                        players.for.app,
                        by = c("nflId"))

write.app.data <- write.app.data[, .(gameId,
                                     playId,
                                     nflId,
                                     displayName,
                                     should_be_tackle,
                                     front_or_behind_receiver,
                                     dist_from_receiver_at_pass_catch,
                                     receiver_dist_from_sideline,
                                     dir_vel,
                                     Impactful_Blocker_Level,
                                     def_dist_rank_level,
                                     Allocated_Prediction)]

# make sure no name duplicates
if(nrow(players.for.app) != nrow(unique(write.app.data[, .(nflId, displayName)]))) {
  print("There are non-unique display names in the data!")
  UNDECLARED()
}

# save app data
saveRDS(write.app.data, "app/app_player_data.rds")

# print number of players
print(paste("Number of players: ", nrow(players.for.app)))


```
